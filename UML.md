# 0 总纲

面向对象编程的目的从来就不是复用，在面向对象兴起之前，编程以面向过程为中心，例如结构化程序设计，然而这种系统已经达到了复杂性极点，这才有了面向对象编程，我们通过提升抽象级别来构建更大的，更复杂的系统，这才是面向对象编程的指导思想

# 1 准备篇

## 1.1 程序设计思想

面向过程的观点认为世界是一个过程，过程是世界的本源，而面向对象发现过程只不过是对象之间的信息传递。

### 1.1.1 面向过程

面向过程的方法，是找到过程的起点，然后顺藤摸瓜，分析每一个部分，直至到达过程的终点，这个过程每一部分都是过程链上不可分割的一环。

然而随着需求越来越复杂，系统越来越庞大，功能点越来越多，一份数据经常被多个过程共享，这些过程对同一份数据的创建和读取越来越趋于复杂和多样，经常出现相互矛盾的数据需求，因此分析和设计也变得越来越困难。

面向过程设计本身蕴含着一个前提假设，即过程是稳定的，所有的工作成果都依赖于对这个过程的步步分析，它导致的一个结果就是，过程的每一步都是预设好的，有着严谨的因果关系，只可惜我们的世界从来不是一成不变的，一切都无时无刻不在发生着变化，系统所依赖的因果关系变得越来越脆弱。

其实并非面向过程的方法不正确，只是构成一个系统的因素太多，要把所有可能的因素都考虑到，把所有因素的因果关系都分析清楚，再把过程模拟出来实在太困难了。

### 1.1.2 面向对象

面向对象将世界看成一个个相互独立的对象，相互之间并无因果关系。只有在某个外部力量的驱使下，对象之间才会依据某种规律传递信息。

抽象是面向对象的精髓所在，也是困难所在，我们需要解决：

- 一种把现实世界映射到对象世界的方法
- 一种从对象世界描述现实世界的方法
- 一种验证对象世界行为是否正确反映现实世界的方法

## 1.2  UML概述

### 1.2.1 可视化

文字难以表达清楚的，复杂的含义，通过图形简单直观低暴露出来

### 1.2.2 模型层次

- 业务模型，即用例
- 概念模型，边界类，实体类，控制类，包，组件，节点
- 设计模型，具体化

### 1.2.3 抽象层次

人脑处理信息的量是有限的，如果信息量超过了人脑的处理能力，人就会失去对这个事物的理解，这是面向过程设计的问题所在。抽象层次越高，信息量越少，越容易理解和处理。但是这又会带来新的问题，信息量不足，实施起来非常困难。这关系到用例的粒度

### 1.2.4 抽象使用的方法

自顶向下，适用于从头认识事物；自底向上，适用于局部改进，量变引起质变。

### 1.2.5 视图

从不同的视角，对事物进行的评估，同样一个信息，视角不同对事物的认知也不同。对于软件来说，从静态、动态、结构性、逻辑性等视角看，会得到不同的视图，如用例图，对象图，类图，包图、活动图等。我们应为特定的人，展示特定的视图。

### 1.2.6 对象分析原则

- 一切皆对象
- 对象都是独立的平时步语别人来往
- 对象都是原子的，不能分割
- 对象都是可抽象的
- 对象具有层次性

### 1.2.7 业务建模做什么

$$
\begin{align}
& 问题领域 = \sum_{1}^n抽象角度\\
& 抽象角度 = 问题领域边界外的参与者（发起者）的业务目标 = 业务用例\\
&业务用例 = \sum_{1}^{n}特定场景
\end{align}
$$



# 2 UML核心元素

## 2.1 版型

版型又叫构造型，它是UML元素的特化，相当于C++的专门化。

## 2.3 业务工人

业务工人不是发起者（参与者），在系统边界之内。

## 2.4 涉众

与系统相关的受益人，会影响系统建设

### 2.4.1 参与者

参与者（发起者）是涉众的代表，不是所有的涉众都是参与者.我觉得叫发起者更贴切，书上说是主角，我觉得不合理。参与者是系统之外与系统交互的人或者物，参与者在系统之外。任何用例必须有发起者，发起者可以非人。

#### 2.4.1.1 业务主角

是参与者的一个版型，业务主角在需求分析阶段，不应该考虑计算机系统，而只应该考虑客户需求。在没有计算机之前，业务一样可以运转

#### 2.4.1.2 准确合理确定参与者

- 是否找到去不参与者，在所有用例弄好后才能定
- 参与者是否都有用例与之对应，没有则删除
- 参与者角色有无重叠
- 参与者目的是否相同，若不同多建几个角色
- 参与者名称角色相符

### 2.4.2 用户

用户是参与者的代表，不是所有的参与者都是用户，代表参与者使用系统

### 2.4.3 角色

角色是参与者职责的分类，但是用户是参与者代表，故也有多个职责

## 2.5 用例

所谓用例，就是一件事情，要完成这件事情，需要一系列的活动，而做一件事情可以有很多不同的办法和步骤，也可能会遇到各种各样的意外情况，因此这件事情是由很多不同的情况的集合构成的，在UML中称之为用例场景，一个场景就是一个用例的实例。

要启动用例是有条件的，要做饭得先有米，因此，一个完整得用例定义由参与者，前置条件、场景、后置条件构成

![aa](https://github.com/wutongtongshu/doc/raw/master/UML/%E7%94%A8%E4%BE%8B%E7%BB%93%E6%9E%84.jpg)

全部参与者的所有愿望都可以通过用例来表达，那么系统就被确定了下来。捕捉功能性需求，这就是用例的作用。

### 2.5.1 用例的特征

- 独立性：不与其他用例交互而独自完成参与者的目的，用例从功能上来说是完备的，不能完整达到参与者的一个愿望的不能称为用例。
- 可观测性：用例对参与者来说结果可观测，而且有意义。
- 必须有参与者
- 用例以动宾短语出现
- 一个用例是一个需求单元、分析单元、设计单元、开发大院、测试单元甚至部署单元

### 2.5.2 用例粒度

项目阶段不同，粒度也不同。业务建模阶段，一个用例说明一个完整的业务流程。用例分析阶段即概念建模阶段，能够描述一件完整的事件流，这个阶段是面向对象的，要进行合理的抽象。系统建模阶段，一个用例描述一次交互为宜

粒度选区问题，实际上还是边界确定问题

### 2.5.3 用例的产生

参与者的愿望

### 2.5.4 业务用例

是用例的版型之一，用于业务建模。

### 2.5.5 业务用例实现

跟业务用例的关系类似于接口和实现的关系，比如缴纳电话费，就有三种实现方式，营业厅缴费、银行缴费、预存话费。这三种都可以完成缴电话费这一愿望。

### 2.5.6 概念用例

用于概念建模，没有规定版型

### 2.5.7 系统用例

业务用例是参与者视角，系统用例是系统视角，是需求的来源，规定了系统的范围。在大象UML中，如果说系统用例，都会省略掉系统两个字，直接使用用例。

### 2.5.8 系统用例实现

在大象UML中，直接称作用例实现。默认的

## 2.6 边界

边界决定视界，边界决定抽象层次，

## 2.7 包

容纳其它元素，是UML元素之一

- 领域包

  ![](https://github.com/wutongtongshu/doc/raw/master/UML/%E9%A2%86%E5%9F%9F%E5%8C%85.jpg)

- 子系统

  ![](https://github.com/wutongtongshu/doc/raw/master/UML/%E5%AD%90%E7%B3%BB%E7%BB%9F.jpg)

- 组织结构

  ![](https://github.com/wutongtongshu/doc/raw/master/UML/%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.jpg)

- 层

  ![](https://github.com/wutongtongshu/doc/raw/master/UML/%E5%B1%82%E5%8C%85.jpg)

## 2.8 分析类

- 边界
- 控制
- 实体

分析类“三高”，高于设计实现，不用考虑通用的设计方法。高于语言，不用考虑实现语言，高于实现方式。

## 2.9 设计类

是对象的抽象，有类型，属性，方法构成

## 2.10 关系

- 关联关系，是结构关系(association)
- 依赖关系，是使用关系，一个变了，会影响另一个行为(dependency)
- 扩展关系(extends)
- 包含关系(include)
- 精化关系，用于用例细分(realize)
- 泛化关系(refine)
- 聚合关系(aggregation)
- 组合关系(composition)

## 2.11 业务实体

业务角色执行用例时使用的事物，业务实体至少被一个用例使用或创建

## 2.12 组件

实现特定功能，特定接口

- 完备性：可进行完整业务处理
- 独立性：可独立部署
- 逻辑性：组件是系统分析的结果
- 透明性：组件不应该被修改

## 2.13 节点

至少一个处理器加内存

# 3 视图

如果第 2 章是基本单词，那么本章就是语法。

## 3.1 静态视图

静态视图有用例图，类图，包图。用例图涉及两个元素用例和参与者。静态视图很好理解，不作过多研究。

## 3.2 动态图

### 3.2.1 活动图

相当于流程图

### 3.2.1 状态图

状态转移视图

### 3.2.3 时序图

交互用

###3.2.4 协作图

分析关系用

# 名词解释

##### GOOD

 通用面向对象开发

##### HOOD 

层次化面向对象方法

##### OOSE 

面向对象结构设计

##### OOA

面向对象分析

#####SOA

面向服务的构架，将系统划分为规则同一的组件

