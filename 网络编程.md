# 1 HTTP概述

## IP地址

IP由网络地址和主机地址组成，

子网掩码：规定 1 或者 0 要连续，标准掩码为 1、2、3字节，若不是这些字节，说明向网络位借位充当主机地址。192.168.1.53/27 ，意思是27位掩码，而 3 字节掩码位 24 位， 说明向 网络位借用了 3 位 ，实际的掩码为

1111111 11111111 111111 11100000 255.255.255.224。由于 IP 和 掩码做 与 运算 得到 网络地址，所以借用的 3 位有 8 中可能，所以是 8 个子网， 掩码中剩余的 5 位 做 与 运算有 32 种可能， 去掉 子网 起点做 网络地址，子网终点做子网的 广播地址， 还剩 30个可用。

　对于192.168.0.0/24，网络地址是192.168.0.0，广播地址是192.168.0.255（后8位为11111111）。
　　对于192.168.0.0/26，网络地址是192.168.0.0，广播地址是192.168.0.63（后8位为00111111）。
　　对于192.168.0.64/26，网络地址是192.168.0.64，广播地址是192.168.0.127（后8位为01111111）。
　　对于192.168.0.128/26，网络地址是192.168.0.128，广播地址是192.168.0.191（后8位为10111111）。 
　　对于192.168.0.192/26，网络地址是192.168.0.192，广播地址是192.168.0.255（后8为为11111111）。



HTTP协议永远都是客户端发起请求，服务器回送响应，无法主动推送。

HTTP协议的主要**特点**可概括如下：

- 支持客户/服务器模式。支持基本认证和安全认证。
- 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
- 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
- **HTTP 0.9和1.0使用非持续连接：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接**。HTTP 1.1使用持续连接：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象，采用这种方式可以节省传输时间。
- 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。

## 1.1 无状态协议

协议的状态是指下一次传输可以**记住**这次传输信息的能力。
http是不会为了下一次连接而**维护**这次连接所传输的信息,为了提高Web服务器对并发访问的处理能力，在设计HTTP协议时规定不保存发出请求的Web浏览器进程的任何状态信息。这有可能出现一个浏览器在短短几秒之内两次访问同一对象时，服务器进程不会因为已经给它发过应答报文而不接受第二期服务请求。由于Web服务器不保存发送请求的Web浏览器进程的任何信息，因此HTTP协议属于无状态协议（Stateless Protocol）。

**HTTP协议是无状态的和Connection: keep-alive的区别**

无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。
HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。
从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。
Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。

## 1.2 工作流程

一次HTTP操作称为一个**事务**，其工作过程可分为四步：
1）首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。
2）建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。
3）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。
4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。
如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。

![img](https://images0.cnblogs.com/i/116165/201407/121703453173884.png)

 

HTTP是基于传输层的TCP协议，而TCP是一个端到端的面向连接的协议。所谓的端到端可以理解为进程到进程之间的通信。所以HTTP在开始传输之前，首先需要建立TCP连接，而TCP连接的过程需要所谓的“三次握手”。下图所示TCP连接的三次握手。
在TCP三次握手之后，建立了TCP连接，此时HTTP就可以进行传输了。一个重要的概念是面向连接，既HTTP在传输完成之间并不断开TCP连接。在HTTP1.1中(通过Connection头设置)这是默认行为。

**五、使用Wireshark抓TCP、http包**

点击"Capture Filter"，此处选择的是"HTTP TCP port（80）"，选择后点击上图的"Start"开始抓包。
然后在浏览器中打开http://image.baidu.com/，抓包结果如下图所示：
![img](https://images0.cnblogs.com/i/116165/201407/121502073952141.png)

在上图中，可清晰的看到客户端浏览器（ip为192.168.1.6）与服务器（115.239.210.36）的交互过程：
1）No1：浏览器（192.168.1.6）向服务器（115.239.210.36）发出连接请求。此为TCP三次握手第一步，此时从图中可以看出，为SYN，seq:X （x=0）；
2）No2：服务器（115.239.210.36）回应了浏览器（192.168.1.6）的请求，并要求确认，此时为：SYN，ACK，此时seq：y（y为0），ACK：x+1（为1）。此为三次握手的第二步；
3）No3：浏览器（192.168.1.6）回应了服务器（115.239.210.36）的确认，连接成功。为：ACK，此时seq：x+1（为1），ACK：y+1（为1）。此为三次握手的第三步；
4）No4：浏览器（192.168.1.6）发出一个页面HTTP请求；
5）No5：服务器（115.239.210.36）确认；
6）No6：服务器（115.239.210.36）发送数据；
7）No8：客户端浏览器（192.168.1.6）确认；
![img](https://images0.cnblogs.com/i/116165/201407/121521541766071.png)

8）No81：客户端（192.168.1.6）发出一个图片HTTP请求；
9）No202：服务器（115.239.210.36）发送状态响应码200 OK。 

## 1.3 请求信息

发出的请求信息格式如下：

```htt
POST /index.html HTTP/1.1   请求方法 url 协议/版本号
Host: localhost  主机
User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: zh-cn,zh;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Referer: <a target=_blank href="http://localhost/" style="color: rgb(51, 102, 153); text-decoration: none;">http://localhost/</a>
Content-Length：25
Content-Type：application/x-www-form-urlencoded

username=aa&password=1234
```

三个部分分别是：请求行、消息报头、请求正文。

### 1.3.1 请求方法

HTTP/1.1协议中共定义了八种方法（有时也叫“动作”）来表明Request-URI指定的资源的不同操作方式：
OPTIONS - 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。
HEAD- 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。
GET - 向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在web app.中。其中一个原因是GET可能会被网络蜘蛛等随意访问。
POST - 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
PUT - 向指定资源位置上传其最新内容。
DELETE - 请求服务器删除Request-URI所标识的资源。
TRACE- 回显服务器收到的请求，主要用于测试或诊断。
CONNECT - HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
PATCH - 用来将局部修改应用于某一资源，添加于规范RFC5789。
方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed）；当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。
HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。

**GET和POST的区别**：
1、GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，如EditPosts.aspx?name=test1&id=123456. POST方法是把提交的数据放在HTTP包的Body中。
2、GET提交的数据大小有限制，最多只能有1024字节（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。
3、GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。
4、GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。

## 1.4 响应消息

客户端向服务器发送一个请求，服务器以一个状态行作为响应，响应的内容包括：消息协议的版本、成功或者错误编码、服务器信息、实体元信息以及必要的实体内容。根据响应类别的类别，服务器响应里可以含实体内容，但不是所有的响应都有实体内容。

```http
HTTP/1.1 200 OK
Date: Sun, 17 Mar 2013 08:12:54 GMT
Server: Apache/2.2.8 (Win32) PHP/5.2.5
X-Powered-By: PHP/5.2.5
Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/
Expires: Thu, 19 Nov 1981 08:52:00 GMT
Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0
Pragma: no-cache
Content-Length: 4393
Keep-Alive: timeout=5, max=100
Connection: Keep-Alive
Content-Type: text/html; charset=utf-8

<html>
<head>
<title>HTTP响应示例<title>
</head>
<body>
Hello HTTP!
</body>
</html></p><p>
```

三个部分分别是：状态行、消息报头、响应正文。
无论你何时浏览一个网页，你的电脑都会通过一个使用HTTP协议的服务器来获取所请求的数据。在你请求的网页显示在浏览器之前，支配网页的网站服务器会返回一个包含有状态码的HTTP头文件。这个状态码提供了有关所请求网页的相关条件信息。如果一切正常，一个标准网页会收到一条诸如200的状态码。当然我们的目的不是去研究200响应码，而是去探讨那些代表出现错误信息的服务器头文件响应码，例如表示“未找到指定网页”的404码。

## 1.5 HTTP常见的请求头

在HTTP/1.1 协议中，所有的请求头，除Host外，都是可选的

If-Modified-Since：把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中。

例如：If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMT
![img](https://images0.cnblogs.com/i/116165/201407/121756006148567.png)

If-None-Match：If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag.  使用这样的机制将提高网站的性能。例如: If-None-Match: "03f2b33c0bfcc1:0"。

![img](https://images0.cnblogs.com/i/116165/201407/121800390202646.png)

Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝；在HTTP/1.1版本中，它和Cache-Control:no-cache作用一模一样。Pargma只有一个用法， 例如： Pragma: no-cache
注意: 在HTTP/1.0版本中，只实现了Pragema:no-cache, 没有实现Cache-Control

Cache-Control：指定请求和响应遵循的缓存机制。缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程）。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage。

Cache-Control:Public 可以被任何缓存所缓存
Cache-Control:Private 内容只缓存到私有缓存中
Cache-Control:no-cache 所有内容都不会被缓存
Cache-Control:no-store 用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。
Cache-Control:max-age 指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。
Cache-Control:min-fresh 指示客户机可以接收响应时间小于当前时间加上指定时间的响应。
Cache-Control:max-stale 指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。

Accept：浏览器端可以接受的MIME类型。例如：Accept: text/html 代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的html文档，如果服务器无法返回text/html类型的数据，服务器应该返回一个406错误(non acceptable)。通配符 * 代表任意类型，例如 Accept: */* 代表浏览器可以处理所有类型，(一般浏览器发给服务器都是发这个)。

Accept-Encoding：浏览器申明自己可接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）;Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。例如： Accept-Encoding: gzip, deflate。如果请求消息中没有设置这个域，服务器假定客户端对各种内容编码都可以接受。

Accept-Language：浏览器申明自己接收的语言。语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等；例如：Accept-Language: en-us。如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。

Accept-Charset：浏览器可接受的字符集。如果在请求消息中没有设置这个域，缺省表示任何字符集都可以接受。

User-Agent：告诉HTTP服务器，客户端使用的操作系统和浏览器的名称和版本。
例如： User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; CIBA; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; InfoPath.2; .NET4.0E)。

Content-Type：例如：Content-Type: application/x-www-form-urlencoded。

Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。
例如: Referer:http://translate.google.cn/?hl=zh-cn&tab=wT

Connection：
例如：Connection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。HTTP 1.1默认进行持久连接。利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。
Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭，当客户端再次发送Request，需要重新建立TCP连接。

Host：（发送请求时，该头域是必需的）主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回。
例如: 我们在浏览器中输入：http://www.guet.edu.cn/index.html，浏览器发送的请求消息中，就会包含Host请求头域：Host：http://www.guet.edu.cn，此处使用缺省端口号80，若指定了端口号，则变成：Host：指定端口号。

Cookie：最重要的请求头之一, 将cookie的值发送给HTTP服务器。

Content-Length：表示请求消息正文的长度。例如：Content-Length: 38。

Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。

UA-Pixels，UA-Color，UA-OS，UA-CPU：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。

From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。

Range：可以请求实体的一个或者多个子范围。例如，
表示头500个字节：bytes=0-499
表示第二个500字节：bytes=500-999
表示最后500个字节：bytes=-500
表示500字节以后的范围：bytes=500-
第一个和最后一个字节：bytes=0-0,-1
同时指定几个范围：bytes=500-600,601-999
但是服务器可以忽略此请求头，如果无条件GET包含Range请求头，响应会以状态码206（PartialContent）返回而不是以200（OK）。

## 1.6 HTTP常见的响应头

Allow：服务器支持哪些请求方法（如GET、POST等）。

Date：表示消息发送的时间，时间的描述格式由rfc822定义。例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦

Expires：指明应该在什么时候认为文档已经过期，从而不再缓存它，重新从服务器获取，会更新缓存。过期之前使用本地缓存。HTTP1.1的客户端和缓存会将非法的日期格式（包括0）看作已经过期。eg：为了让浏览器不要缓存页面，我们也可以将Expires实体报头域，设置为0。
例如: Expires: Tue, 08 Feb 2022 11:35:14 GMT

P3P：用于跨域设置Cookie, 这样可以解决iframe跨域访问cookie的问题
例如: P3P: CP=CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR

Set-Cookie：非常重要的header, 用于把cookie发送到客户端浏览器，每一个写入cookie都会生成一个Set-Cookie。
例如: Set-Cookie: sc=4c31523a; path=/; domain=.acookie.taobao.com

ETag：和If-None-Match 配合使用。

Last-Modified：用于指示资源的最后修改日期和时间。Last-Modified也可用setDateHeader方法来设置。

Content-Type：WEB服务器告诉浏览器自己响应的对象的类型和字符集。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。可在web.xml文件中配置扩展名和MIME类型的对应关系。
例如:Content-Type: text/html;charset=utf-8
　　 Content-Type:text/html;charset=GB2312
　　 Content-Type: image/jpeg

媒体类型的格式为：大类/小类，比如text/html。
IANA(The Internet Assigned Numbers Authority，互联网数字分配机构)定义了8个大类的媒体类型，分别是:
application— (比如: application/vnd.ms-excel.)
audio (比如: audio/mpeg.)
image (比如: image/png.)
message (比如,:message/http.)
model(比如:model/vrml.)
multipart (比如:multipart/form-data.)
text(比如:text/html.)
video(比如:video/quicktime.)

Content-Range：用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式：Content-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-length。
例如，传送头500个字节次字段的形式：Content-Range:bytes0-499/1234如果一个http消息包含此节（例如，对范围请求的响 应或对一系列范围的重叠请求），Content-Range表示传送的范围。

Content-Length：指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。
例如: Content-Length: 19847

Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader("Accept-Encoding")）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。
例如：Content-Encoding：gzip

Content-Language：WEB服务器告诉浏览器自己响应的对象所用的自然语言。例如： Content-Language:da。没有设置该域则认为实体内容将提供给所有的语言阅读。

Server：指明HTTP服务器用来处理请求的软件信息。例如：Server: Microsoft-IIS/7.5、Server：Apache-Coyote/1.1。此域能包含多个产品标识和注释，产品标识一般按照重要性排序。

X-AspNet-Version：如果网站是用ASP.NET开发的，这个header用来表示ASP.NET的版本。
例如: X-AspNet-Version: 4.0.30319

X-Powered-By：表示网站是用什么技术开发的。
例如： X-Powered-By: ASP.NET

Connection：
例如：Connection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。
Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭，当客户端再次发送Request，需要重新建立TCP连接。

Location：用于重定向一个新的位置，包含新的URL地址。表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。Location响应报头域常用在更换域名的时候。

Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader("Refresh", "5; URL=http://host/path")让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的<META HTTP-EQUIV="Refresh" CONTENT="5;URL=http://host/path">实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是<META HTTP-EQUIV="Refresh" ...>。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。

WWW-Authenticate：该响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。
eg：WWW-Authenticate:Basic realm="Basic Auth Test!" //可以看出服务器对请求资源采用的是基本验证机制。

## 1.7 解决HTTP无状态的问题

### 1.7.1 通过Cookies保存状态信息

通过Cookies，服务器就可以清楚的知道请求2和请求1来自同一个客户端。
![img](https://images0.cnblogs.com/i/116165/201407/122123269892896.png)

### 1.7.2 通过Session保存状态信息

Session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。
当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识 - 称为 session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个 session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。

**Session的实现方式：**

1、使用Cookie来实现
服务器给每个Session分配一个唯一的JSESSIONID，并通过Cookie发送给客户端。
当客户端发起新的请求的时候，将在Cookie头中携带这个JSESSIONID。这样服务器能够找到这个客户端对应的Session。
![img](https://images0.cnblogs.com/i/116165/201407/122202523952651.png)

2、使用URL回写来实现
URL回写是指服务器在发送给浏览器页面的所有链接中都携带JSESSIONID的参数，这样客户端点击任何一个链接都会把JSESSIONID带会服务器。如果直接在浏览器输入服务端资源的url来请求该资源，那么Session是匹配不到的。
Tomcat对Session的实现，是一开始同时使用Cookie和URL回写机制，如果发现客户端支持Cookie，就继续使用Cookie，停止使用URL回写。如果发现Cookie被禁用，就一直使用URL回写。jsp开发处理到Session的时候，对页面中的链接记得使用response.encodeURL() 。

**Cookie和Session有以下明显的不同点：**
1）Cookie将状态保存在客户端，Session将状态保存在服务器端；
2）Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。Cookie最早在RFC2109中实现，后续RFC2965做了增强。网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies。Session并没有在HTTP的协议中定义；
3）Session是针对每一个用户的，变量的值保存在服务器上，用一个sessionID来区分是哪个用户session变量,这个值是通过用户的浏览器在访问的时候返回给服务器，当客户禁用cookie时，这个值也可能设置为由get来返回给服务器；
4）就安全性来说：当你访问一个使用session 的站点，同时在自己机子上建立一个cookie，建议在服务器端的SESSION机制更安全些。因为它不会任意读取客户存储的信息。

3、通过表单变量保持状态
除了Cookies之外，还可以使用表单变量来保持状态，比如Asp.net就通过一个叫ViewState的Input=“hidden”的框来保持状态,比如:
<input type="hidden" name="__VIEWSTATE" id="__VIEWSTATE" value="/wEPDwUKMjA0OTM4MTAwNGRkXUfhlDv1Cs7/qhBlyZROCzlvf5U=" />
这个原理和Cookies大同小异，只是每次请求和响应所附带的信息变成了表单变量。

4、通过QueryString保持状态

QueryString通过将信息保存在所请求地址的末尾来向服务器传送信息，通常和表单结合使用，一个典型的QueryString比如:www.xxx.com/xxx.aspx?var1=value&var2=value2

## 1.8 使用telnet进行http测试

在Windows下，打开命令行工具输入：

- telnet www.baidu.com 80

- 按下"Ctrl+]"打开本地回显功能。出现**Microsoft Telnet>**，按回车进入telnet工具输入界面

- 接着开始发请求消息，使用的HTTP协议为HTTP/1.1：

   GET /index.html HTTP/1.1

- 连着按两次回车，第一个回车换行是在命令后键入回车换行，是HTTP协议要求的。第二个是确认输入，发送请求。

以上这些步骤要快，否则会报失去连接。

![img](https://images0.cnblogs.com/i/116165/201407/121638564269748.png)

可看到，当采用HTTP/1.1时，连接不是在请求结束后就断开的。若采用HTTP1.0，在命令窗口键入：
GET /index.html HTTP/1.0
此时可以看到请求结束之后马上断开。

## 1.9 缓存的实现原理

WEB缓存(cache)位于Web服务器和客户端之间。
缓存会根据请求保存输出内容的副本，例如html页面，图片，文件，当下一个请求来到的时候：如果是相同的URL，缓存直接使用副本响应访问请求，而不是向源服务器再次发送请求。
HTTP协议定义了相关的消息头来使WEB缓存尽可能好的工作。

### 1.9.1 缓存的优点

减少相应延迟：因为请求从缓存服务器（离客户端更近）而不是源服务器被相应，这个过程耗时更少，让web服务器看上去相应更快。
减少网络带宽消耗：当副本被重用时会减低客户端的带宽消耗；客户可以节省带宽费用，控制带宽的需求的增长并更易于管理。

### 1.9.2 客户端缓存生效的常见流程

服务器收到请求时，会在200OK中回送该资源的Last-Modified和ETag头，客户端将该资源保存在cache中，并记录这两个属性。当客户端需要发送相同的请求时，会在请求中携带If-Modified-Since和If-None-Match两个头。两个头的值分别是响应中Last-Modified和ETag头的值。服务器通过这两个头判断本地资源未发生变化，客户端不需要重新下载，返回304响应。

### 1.9.3 Web缓存机制

HTTP/1.1中缓存的目的是为了在很多情况下减少发送请求，同时在许多情况下可以不需要发送完整响应。前者减少了网络回路的数量；HTTP利用一个“过期（expiration）”机制来为此目的。后者减少了网络应用的带宽；HTTP用“验证（validation）”机制来为此目的。
HTTP定义了3种缓存机制：
1）Freshness：允许一个回应消息可以在源服务器不被重新检查，并且可以由服务器和客户端来控制。例如，Expires回应头给了一个文档不可用的时间。Cache-Control中的max-age标识指明了缓存的最长时间；
2）Validation：用来检查以一个缓存的回应是否仍然可用。例如，如果一个回应有一个Last-Modified回应头，缓存能够使用If-Modified-Since来判断是否已改变，以便判断根据情况发送请求；
3）Invalidation：在另一个请求通过缓存的时候，常常有一个副作用。例如，如果一个URL关联到一个缓存回应，但是其后跟着POST、PUT和DELETE的请求的话，缓存就会过期

## 1.10 HTTP应用

断点续传的实现原理***

HTTP协议的GET方法，支持只请求某个资源的某一部分；
Partial Content 部分内容响应；
Range 请求的资源范围；
Content-Range 响应的资源范围；
在连接断开重连时，客户端只请求该资源未下载的部分，而不是重新请求整个资源，来实现断点续传。
分块请求资源实例：
Eg1：Range: bytes=306302- ：请求这个资源从306302个字节到末尾的部分；
Eg2：Content-Range: bytes 306302-604047/604048：响应中指示携带的是该资源的第306302-604047的字节，该资源共604048个字节；
客户端通过并发的请求相同资源的不同片段，来实现对某个资源的并发分块下载。从而达到快速下载的目的。目前流行的FlashGet和迅雷基本都是这个原理。

## 1.11 多线程下载的原理

下载工具开启多个发出HTTP请求的线程；
每个http请求只请求资源文件的一部分：Content-Range: bytes 20000-40000/47000；
合并每个线程下载的文件。

## 1.12 http代理

http代理服务器

代理服务器英文全称是Proxy Server，其功能就是代理网络用户去取得网络信息。形象的说：它是网络信息的中转站。
代理服务器是介于浏览器和Web服务器之间的一台服务器，有了它之后，浏览器不是直接到Web服务器去取回网页而是向代理服务器发出请求，Request信号会先送到代理服务器，由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。
而且，大部分代理服务器都具有缓冲的功能，就好象一个大的Cache，它有很大的存储空间，它不断将新取得数据储存到它本机的存储器上，如果浏览器所请求的数据在它本机的存储器上已经存在而且是最新的，那么它就不重新从Web服务器取数据，而直接将存储器上的数据传送给用户的浏览器，这样就能显著提高浏览速度和效率。更重要的是：Proxy Server(代理服务器)是Internet链路级网关所提供的一种重要的安全功能，它的工作主要在开放系统互联(OSI)模型的对话层。

http代理服务器的主要**功能**：

1）突破自身IP访问限制，访问国外站点。如：教育网、169网等网络用户可以通过代理访问国外网站；
2）访问一些单位或团体内部资源，如某大学FTP(前提是该代理地址在该资源的允许访问范围之内)，使用教育网内地址段免费代理服务器，就可以用于对教育 网开放的各类FTP下载上传，以及各类资料查询共享等服务；
3）突破中国电信的IP封锁：中国电信用户有很多网站是被限制访问的，这种限制是人为的，不同Serve对地址的封锁是不同的。所以不能访问时可以换一个国外的代理服务器试试；
4）提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息，传给用户，以提高访问速度；
5）隐藏真实IP：上网者也可以通过这种方法隐藏自己的IP，免受攻击。

对于客户端浏览器而言，http代理服务器相当于服务器。
而对于Web服务器而言，http代理服务器又担当了客户端的角色。

## 1.13 虚拟主机

虚拟主机：是在网络服务器上划分出一定的磁盘空间供用户放置站点、应用组件等，提供必要的站点功能与数据存放、传输功能。 
所谓虚拟主机，也叫“网站空间”就是把一台运行在互联网上的服务器划分成多个“虚拟”的服务器，每一个虚拟主机都具有独立的域名和完整的Internet服务器（支持WWW、FTP、E-mail等）功能。一台服务器上的不同虚拟主机是各自独立的，并由用户自行管理。但一台服务器主机只能够支持一定数量的虚拟主机，当超过这个数量时，用户将会感到性能急剧下降。

虚拟主机的**实现原理**

虚拟主机是用同一个WEB服务器，为不同域名网站提供服务的技术。Apache、Tomcat等均可通过配置实现这个功能。
相关的HTTP消息头：Host。
例如：Host: www.baidu.com
客户端发送HTTP请求的时候，会携带Host头，Host头记录的是客户端输入的域名。这样服务器可以根据Host头确认客户要访问的是哪一个域名。

## 1.14 HTTP认证方式

HTTP请求报头： Authorization
HTTP响应报头： WWW-Authenticate

HTTP认证是基于质询/回应(challenge/response)的认证模式。

### 1.14.1 基本认证

basic authentication（HTTP1.0提出的认证方法）

基本认证是一种用来允许Web浏览器或其他客户端程序在请求时提供用户名和口令形式的身份凭证的一种登录验证方式。

把 "用户名+冒号+密码"用BASE64算法加密后的字符串放在http request 中的header Authorization中发送给服务端。
客户端对于每一个realm，通过提供用户名和密码来进行认证的方式。
包含密码的明文传递。

当浏览器访问使用基本认证的网站的时候， 浏览器会提示你输入用户名和密码，如下图：
![img](https://images0.cnblogs.com/i/116165/201407/151617269597376.jpg)
假如用户名密码错误的话，服务器会返回401，如下图：
![img](https://images0.cnblogs.com/i/116165/201407/151618318182929.jpg)

基本认证步骤：
1、客户端访问一个受http基本认证保护的资源。
2、服务器返回401状态，要求客户端提供用户名和密码进行认证。（验证失败的时候，响应头会加上WWW-Authenticate: Basic realm="请求域"。）
401 Unauthorized
WWW-Authenticate： Basic realm="WallyWorld"
3、客户端将输入的用户名密码用Base64进行编码后，采用非加密的明文方式传送给服务器。
Authorization: Basic xxxxxxxxxx.
4、服务器将Authorization头中的用户名密码解码并取出，进行验证，如果认证成功，则返回相应的资源。如果认证失败，则仍返回401状态，要求重新进行认证。

特记事项：
1、Http是无状态的，同一个客户端对同一个realm内资源的每一个访问会被要求进行认证。
2、客户端通常会缓存用户名和密码，并和authentication realm一起保存，所以，一般不需要你重新输入用户名和密码。
3、以非加密的明文方式传输，虽然转换成了不易被人直接识别的字符串，但是无法防止用户名密码被恶意盗用。虽然用肉眼看不出来，但用程序很容易解密。

优点：
基本认证的一个优点是基本上所有流行的网页浏览器都支持基本认证。基本认证很少在可公开访问的互联网网站上使用，有时候会在小的私有系统中使用（如路由器
网页管理接口）。后来的机制HTTP摘要认证是为替代基本认证而开发的，允许密钥以相对安全的方式在不安全的通道上传输。

程序员和系统管理员有时会在可信网络环境中使用基本认证，使用Telnet或其他明文网络协议工具手动地测试Web服务器。这是一个麻烦的过程，但是网络上传输的 
内容是人可读的，以便进行诊断。

缺点：
虽然基本认证非常容易实现，但该方案建立在以下的假设的基础上，即：客户端和服务器主机之间的连接是安全可信的。特别是，如果没有使用SSL/TLS这样的传输 
层安全的协议，那么以明文传输的密钥和口令很容易被拦截。该方案也同样没有对服务器返回的信息提供保护。

现存的浏览器保存认证信息直到标签页或浏览器被关闭，或者用户清除历史记录。HTTP没有为服务器提供一种方法指示客户端丢弃这些被缓存的密钥。这意味着服务 
器端在用户不关闭浏览器的情况下，并没有一种有效的方法来让用户登出。

**一个例子：**

这一个典型的HTTP客户端和HTTP服务器的对话，服务器安装在同一台计算机上（localhost），包含以下步骤：

客户端请求一个需要身份认证的页面，但是没有提供用户名和口令。这通常是用户在地址栏输入一个URL，或是打开了一个指向该页面的链接。服务端响应一个401应 
答码，并提供一个认证域。接到应答后，客户端显示该认证域（通常是所访问的计算机或系统的描述）给用户并提示输入用户名和口令。此时用户可以选择确定或取
消。用户输入了用户名和口令后，客户端软件会在原先的请求上增加认证消息头（值是base64encode(username+":"+password)），然后重新发送再次尝试。
在本例中，服务器接受了该认证屏幕并返回了页面。如果用户凭据非法或无效，服务器可能再次返回401应答码，客户端可以再次提示用户输入口令。
注意:客户端有可能不需要用户交互，在第一次请求中就发送认证消息头。

```
客户端请求（没有认证信息）：
GET /private/index.html HTTP/1.0
Host: localhost
（跟随一个换行，以回车（CR）加换行（LF）的形式）
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
服务端应答：
HTTP/1.0 401 Authorization Required
Server: HTTPd/1.0
Date: Sat, 27 Nov 2004 10:18:15 GMT
WWW-Authenticate: Basic realm="Secure Area"
Content-Type: text/html
Content-Length: 311
 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<HTML>
  <HEAD>
    <TITLE>Error</TITLE>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
  </HEAD>
  <BODY><H1>401 Unauthorized.</H1></BODY>
</HTML>
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
客户端的请求（用户名“"Aladdin”，口令, password “open sesame”）：
GET /private/index.html HTTP/1.0
Host: localhost
Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
（跟随一个空行，如上所述）
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
服务端的应答：
HTTP/1.0 200 OK
Server: HTTPd/1.0
Date: Sat, 27 Nov 2004 10:19:07 GMT
Content-Type: text/html
Content-Length: 10476
（跟随一个空行，随后是需凭据页的HTML文本）。
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

HTTP OAuth认证
OAuth对于Http来说，就是放在Authorization header中的不是用户名密码， 而是一个token。微软的Skydrive就是使用这样的方式。

### 1.14.2 摘要认证

digest authentication（HTTP1.1提出的基本认证的替代方法）

这个认证可以看做是基本认证的增强版本，不包含密码的明文传递。

引入了一系列安全增强的选项；“保护质量”(qop)、随机数计数器由客户端增加、以及客户生成的随机数。
![img](https://images0.cnblogs.com/i/116165/201407/161107320844962.jpg)

在HTTP摘要认证中使用 MD5 加密是为了达成"不可逆的"，也就是说，当输出已知的时候，确定原始的输入应该是相当困难的。如果密码本身太过简单，也许可以 
通过尝试所有可能的输入来找到对应的输出（穷举攻击），甚至可以通过字典或者适当的查找表加快查找速度。

**示例及说明**
下面的例子仅仅涵盖了“auth”保护质量的代码，因为在撰写期间，所知道的只有Opera和Konqueror网页浏览器支持“auth-int”（带完整性保护的认证）。

典型的认证过程包括如下步骤：
客户端请求一个需要认证的页面，但是不提供用户名和密码。通常这是由于用户简单的输入了一个地址或者在页面中点击了某个超链接。
服务器返回401 "Unauthorized" 响应代码，并提供认证域(realm)，以及一个随机生成的、只使用一次的数值，称为密码随机数 nonce。
此时，浏览器会向用户提示认证域(realm)（通常是所访问的计算机或系统的描述），并且提示用户名和密码。用户此时可以选择取消。
一旦提供了用户名和密码，客户端会重新发送同样的请求，但是添加了一个认证头包括了响应代码。

注意：客户端可能已经拥有了用户名和密码，因此不需要提示用户，比如以前存储在浏览器里的。

```
客户端请求 (无认证)：
GET /dir/index.html HTTP/1.0
Host: localhost
(跟随一个新行，形式为一个回车再跟一个换行）
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
服务器响应：
HTTP/1.0 401 Unauthorized
Server: HTTPd/0.9
Date: Sun, 10 Apr 2005 20:26:47 GMT
WWW-Authenticate: Digest realm="testrealm@host.com",   //认证域
                        qop="auth,auth-int",   //保护质量
                        nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",  //服务器密码随机数
                        opaque="5ccc069c403ebaf9f0171e9517f40e41"
Content-Type: text/html
Content-Length: 311

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<HTML>
  <HEAD>
    <TITLE>Error</TITLE>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
  </HEAD>
  <BODY><H1>401 Unauthorized.</H1></BODY>
</HTML>
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
客户端请求 (用户名 "Mufasa", 密码 "Circle Of Life")：
GET /dir/index.html HTTP/1.0
Host: localhost
Authorization: Digest username="Mufasa",
                     realm="testrealm@host.com",
                     nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
                     uri="/dir/index.html",
                     qop=auth,
                     nc=00000001,    //请求计数
                     cnonce="0a4f113b",   //客户端密码随机数
                     response="6629fae49393a05397450978507c4ef1",
                     opaque="5ccc069c403ebaf9f0171e9517f40e41"
(跟随一个新行，形式如前所述)。
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
服务器响应：
HTTP/1.0 200 OK
Server: HTTPd/0.9
Date: Sun, 10 Apr 2005 20:27:03 GMT
Content-Type: text/html
Content-Length: 7984
(随后是一个空行，然后是所请求受限制的HTML页面)
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

response 值由三步计算而成。当多个数值合并的时候，使用冒号作为分割符：

1、对用户名、认证域(realm)以及密码的合并值计算 MD5 哈希值，结果称为 HA1。
2、对HTTP方法以及URI的摘要的合并值计算 MD5 哈希值，例如，"GET" 和 "/dir/index.html"，结果称为 HA2。
3、对HA1、服务器密码随机数(nonce)、请求计数(nc)、客户端密码随机数(cnonce)、保护质量(qop)以及 HA2 的合并值计算 MD5 哈希值。结果即为客户端提供的 
response 值。
因为服务器拥有与客户端同样的信息，因此服务器可以进行同样的计算，以验证客户端提交的 response 值的正确性。在上面给出的例子中，结果是如下计算的。 
（MD5()表示用于计算MD5哈希值的函数；“\”表示接下一行；引号并不参与计算）

HA1 = MD5( "Mufasa:testrealm@host.com:Circle Of Life" )
​       = 939e7578ed9e3c518a452acee763bce9

HA2 = MD5( "GET:/dir/index.html" )
​       = 39aff3a2bab6126f332b942af96d3366

Response = MD5( "939e7578ed9e3c518a452acee763bce9:\
​                         dcd98b7102dd2f0e8b11d0f600bfb0c093:\
00000001:0a4f113b:auth:\
39aff3a2bab6126f332b942af96d3366" )
= 6629fae49393a05397450978507c4ef1

此时客户端可以提交一个新的请求，重复使用服务器密码随机数(nonce)（服务器仅在每次“401”响应后发行新的nonce），但是提供新的客户端密码随机数(cnonce)。在后续的请求中，十六进制请求计数器(nc)必须比前一次使用的时候要大，否则攻击者可以简单的使用同样的认证信息重放老的请求。由服务器来确保在每个发出的密码随机数nonce时，计数器是在增加的，并拒绝掉任何错误的请求。显然，改变HTTP方法和/或计数器数值都会导致不同的 response值。

服务器应当记住最近所生成的服务器密码随机数nonce的值。也可以在发行每一个密码随机数nonce后，记住过一段时间让它们过期。如果客户端使用了一个过期的值，服务器应该响应“401”状态号，并且在认证头中添加stale=TRUE，表明客户端应当使用新提供的服务器密码随机数nonce重发请求，而不必提示用户其它用户名和口令。

服务器不需要保存任何过期的密码随机数，它可以简单的认为所有不认识的数值都是过期的。服务器也可以只允许每一个服务器密码随机数nonce使用一次，当然，这样就会迫使客户端在发送每个请求的时候重复认证过程。需要注意的是，在生成后立刻过期服务器密码随机数nonce是不行的，因为客户端将没有任何机会来使用这个nonce。

*PS：以上只介绍了两种比较基础的，还有其他的一些认证方式就不在这里一一说明了。*

## 1.15 HTTPS传输协议原理

HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容请看SSL。

### 1.15.1 两种基本的加解密算法类型

对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等。
非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。

### 1.15.2 HTTPS通信过程

![img](https://images0.cnblogs.com/i/116165/201407/122142366922455.png)

### 1.15.3 HTTPS通信的优点

客户端产生的密钥只有客户端和服务器端能得到；
加密的数据只有客户端和服务器端才能得到明文；
客户端到服务端的通信是安全的。

## 1.16 http的状态响应码

结束语：其他协议还有：文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等。

# 2 简单Web服务器

1. 主线程启动HttpServer

2. 使用 HttpServer 的对象的 await 方法，阻塞 main 线程

3. 在 awati 方法中循环，直到收到关闭信号

   从socket中取出inputStream封装成Request，并解析出url

   从socket中取出outputStream封装成Response

   关闭socket，等待下一个socket连接进来。

# 3 使用servlet的Web服务器

- 若为第一次调用servlet，初始化

- 从socket输入流，输出流封装成requst和response

- 调用相关servlet，完成业务逻辑

  # 网络基础

  ## 1 集线器

  　　集线器（HUB），它是工作在物理层的设备， 由于它只是工作在物理层，它的工作机制流程是：从一个端口接收到数据包时，会在其他端口把这个包转发一次，因为它不知道也不可能知道这个包是发给谁的（物理层设备只关心电压这些物理概念），它也只能对所有人广播(这里和下文提到的 广播该词的意思和ARP请求时的广播有些不同，这里的广播意思是：使用物理层转发设备，如HUB，导致的广播，可以说这个广播是被逼的，因为设备的问题！ 是设备转发包引起的广播！而ARP请求的广播是自己要求的，主动的，因为ARP请求包的目标地址IP是255.255.255.255，但ARP请求的广 播涉及IP层的知识，不在这篇文章讨论的范围，所以这里提到的广播，除非特别说明，否则都是第一个意思，也就说是"因设备转发数据包引起的广播" )。

  　　这样一来会有不少问题，你发的数据其他人都收到了，私隐这总东西是不存在的！别入可以随便监听你信息！所以会话劫持在那个年代相当容易。

  　　另外一个比较严重的问题是，如果一个大型的局域网，比如有500台机器，全部用HUB连接的无用的数据包会充斥着整个的局域网，这就是传说中的广播风暴！

  　　为了减少广播风暴，**网桥**产生了（注意这里用的时候“减少”，不是“杜绝”，仅仅是减少!如果仅仅用网桥说能杜绝广播风暴，个人觉得还是不太准确，后来交换机的出现才可以说是完全杜绝了广播风暴的发生）！

  　　在介绍网桥之前，还想简单介绍另一个物理层的设备：“中继器”，这种设备的作用是把物理层传输的信号放大，由于长距离的传输，信号会有一定的损耗的，这种设备主要解决的就是这个问题。它和HUB的区别是：HUB主要是为了在物理层上转发数据的，所以它不关心电压值的大小，也不会放大物理信号；而中继器它的作用就是为了放大信号用的

  ## 2 网桥

  　　网桥又称桥接器，英文名Network Bridge，**数据链路层设备**。它也是转发数据包的设备，但和HUB不一样的是，它工作在数据链路层，HUB只能看懂物理层上的东西（比如一段物理信号），网桥却能看懂一些帧的信息（在链路层上，把上面传下来的数据封装后，封装好了的数据就是帧，但这里我用“数据包”这样的泛指去代替“帧”这个专业术语）。在以太网构造的局域网上，最终的寻址是以数据链路层的MAC地址作为标识的(就是用MAC地址可以在局域网上找到一台唯一的机器)，网桥能从发来的数据包中提取MAC信息，并且根据MAC信息对数据包进行有目的的转发，而不采用广播的方式，这样就能减少广播风暴的出现，提升整个网络的效率，在详细说网桥这东西之前，我想先介绍一下交换机。

  ## 3 交换机

  　　交换机Switch，数据链路层设备，作用是转发数据包。和网桥一样它也是通过识别帧中的MAC地址，然后对特定的端口进行转发的。

  ### 3.1 网桥和交换机的工作原理及区别

  　　回答网桥和交换机区别之前，我们先一起看两幅图(这是从《计算机网络(第四版)》第四章截下来的:>)：

  　　1.网桥的连接模式：(红点处为HUB)

  　　![img](https://github.com/wutongtongshu/img/raw/master/Network/%E9%9B%86%E7%BA%BF%E5%99%A8.jpg)

  　　2.交换机连接模式：

  　　![img](https://github.com/wutongtongshu/img/raw/master/Network/%E4%BA%A4%E6%8D%A2%E6%9C%BA.jpg)

  　　从图中可以看到，网桥只有2个输入/出端口，而交换机有8个。嗯，是的，一开始的时候(那时候只有HUB这种设备)，由于硬件水平不是很发达，人们为了提高局域网效率，减少广播风暴的出现，他们生产了网桥（一个只有两个输入/出端口的链路层设备，这时的网桥已经是个比较先进的设备），然后他们把一个局域网一分为2，中间用网桥连接，这样A发给BCD的数据就不会再广播到EFGH了(网桥发现如果数据包不是转发给下面这个子网的，它会自动丢弃此包)，只有从A发到EFGH的数据包才能通过网桥，到达另外一个子网(网桥发现如果数据包是转发给下面这个子网的，它才会把包转发给这个子网)。这样一来，非必要的传输减少了，整个网络的效率也随之提高可不少！人们发现网桥真是个好东西呀，随着硬件发展，出现了4个，8个端口的链路层设备，这就是交换机，由于交换机可以使得网络更安全(数据不容易被监听，因为数据不再广播了，注意：只是不容易而已，要搞你其实还是可以的)，网络效率更高(还是因为数据不再广播！)，交换机渐渐替代了HUB，成为组建局域网的重要设备。

  　　所以说，网桥和交换机，基本上是一样的，嗯，只是基本上而已，细看还是有些不一样的，但在说明他们之间有什么不一样之前，我想先简单介绍一下网桥和交换机的工作原理。

  　　3.网桥的工作原理：　　

  ![img](https://github.com/wutongtongshu/img/raw/master/Network/%E7%BD%91%E6%A1%A5%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg)

  　　上图是用一个网桥连接的两个网络，网桥的A端口连接A子网，B端口连接B子网，为什么网桥知道哪些数据包该转发，哪些包不该转发呢？那是因为它有两个表A和B，当有数据包进入端口A时，网桥从数据包中提取出源MAC地址和目的MAC地址，一开始的时候，表A和表B都是空的，没有一条记录，这时，网桥会把数据包转发给B网络，并且在表A中增加一条MAC地址(把**源MAC地址记录表中**)，说明这个MAC地址的机器是A子网的，同理，当B子网发送数据包到B端口时，网桥也会记录**源MAC地址**到B表；当网桥工作一段时候后，表A基本上记录了A子网所有的机器的MAC地址，表B同理，当再有一个数据包从A子网发送给网桥时，网桥会先看看数据包的目的MAC地址是属于A子网还是B子网的，如果从A表中找到对应则，抛弃该包，如果不是，则转发给B子网，然后检查源MAC地址，是否在表中已经存在，如果不存在，在表A中增加一条记录。

  　　噢，或许你现在会问了，为什么需要两张表呢，一张表不行么？？嗯～刚才把表一分为二是为了便于理解，实际上，真正的网桥里面存的应该是一张表(当然有可能为了提速，或者其他原因，它也可能把信息存为多张表，这个得看它怎么实现了～)，如果是一张信息表，表里记录的应该是：MAC-PortNum。

  　　4.交换机有些许不同，如图：

  ![img](https://github.com/wutongtongshu/img/raw/master/Network/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg)

  　　交换机也有一张MAC-PORT对应表(这张表的学名为：**CAM**)，和网桥不一样的是，网桥的表是一对多的(一个端口号对多个MAC地址)，但交换机的CAM表却是一对一的，如果一个端口有新的MAC地址，它不会新增MAC－PORT记录，而是修改原有的记录，比如：现在交换机记录表里已经有一项：MAC1-Port1，如果此刻端口1又来了一个数据包，里面的源MAC地址是MAC2，此时，交换机会刷新交换机记录表：MAC1-Port1记录被修改为MAC2－Port1，因为交换机认为是端口1的计算机MAC地址变了，如果端口1连接的一台物理机器，MAC一般是不会变的，如果连接的是另外一个交换机，那这个端口的记录会变化得比较频繁(如上图的Port12，它是对外的接口，与一个局域网连接)，另外，如果CAM表中没有找到和数据包的目的MAC地址对应的记录，交换机会对此数据包进行广播，发给本交换机的每一个端口。

  　　网桥和交换机除了用CAM表指导数据包转发这点和HUB不一样外，网桥和交换机还有一个特点：缓存！对，网桥和交换机都有一定量的缓存，因为网桥和交换机转发数据包需要一些额外的操作，所以可能会占用一些时间，为了避免出现因来不及转发数据，导致大量数据丢失的情况，网桥和交换机就出现了缓存。当然，缓存不是万能的，当网桥或交换机处理不及并且缓存用完了，以后再来的数据还是会丢失的。还一个网桥需要缓存的原因是：桥接两个传输速率不同的局域网，比如：802.3的传输速率说10mb/s，但实际上并不是真的10Mb/s，而 802.4(几乎)确实为10Mb/s，但两个局域网桥接时候必须是速率一样的，否则会有包丢失，而缓存也正好可以为不同速率网络连接时所使用。这里需要对比一下网桥和交换机的缓存，一般来说，网桥的缓存量是大于交换机的缓存量，因为网桥天生是为了连接两个网络的，两个网络桥接时所要处理的数据量会比一般的交换机需要处理的数据量要多，所以网桥的缓存也一般要比交换机大一点。

  　　值得注意的一些问题：

  　　1). 网桥需要软件辅助？

  　　回答这个问题，首先要看看原始的网桥，《计算机网络(第四版)》里有一段话是这样的：传统上，网桥往往包含一个CPU，"转发-存储"由软件来实现。噢，**以前的网桥是这样的**，但现在由于硬件水平的提升，网桥，交换机都包含了特殊的，用于转发的集成电路部分，现在的网桥和交换机都可以不需要软件辅助了！顺带说一句，模拟网桥功能的软件现在也是有的。

  　　2). 网桥用于连接不同的网段？(搜索百度时查到一个答案)

  　　首先这里要理解什么是**网段**，唉，这个概念说起来又是一篇文章！它涉及到子网掩码的等等一系列的东西....

  　　这里我觉得要明确的是，**网桥不是用来连接不同网段的**！！！我当初被这个问题害惨了，K了N多资料，不过还好，有点收获:>，不同网段之间通信，需要网关的帮助，它一般是路由器这类网络层的设备。网桥或交换机是链路层设备，网段这个是和IP相关的概念，属于网络层。网桥和交换机跟本无能力去处理网络层的东西！如果非要说用网桥和交换机去连接两个不同网段的网络不是不行，只是没有作用而已，因为不同网段机器的始终是不能互访问，网桥不能做网关！上面我已经说了网桥的由来，它是为了减少HUB的广播，提高局域网网络性能出现的，网桥连接的仅仅是两个子局域网，并且这里说的子局域网必须是同构的(同构的意思是：如果是以太网，那么网桥连接的两个子网都必须是以太网，不能一个是以太网一个是令牌网)，我一直认为：以太网的特性导致了网桥的出现，因为广播是以太网的重要特性，其他构造的网络不一定有（呀～这里我猜的，我对其他的结构的网络是一巧不通的说-_-!），为了优化以太网的性能，网桥出现了～所以**其他构造网络似乎也不需要使用网桥**这个东东！其实后来带着这个想法继续看无线网络的东西，发现这个想法应该是错误的，**网桥的天性应该是：连接两个同构网络**，而在以太网上，刚好HUB可以作为连接两个网络的设备，但是由于HUB的各种弊端，人们研发了工作在链路层上的网桥（本文所介绍的），它除了连接两个网络的功能外，还有优化网络性能的功能。而在其他构造的网络也有网桥这个设备，但它的功能可能是仅仅连接两个网络，而没有了优化网络性能的功能（或者根据网络特性，它又有了新的功能）。

  　　**这里再次总结一下网桥和交换机**：

  　　网桥和交换机用户**分割冲突域**，就是网桥和交换机可以较少**被逼的广播(hub导致的)**，但**不能分割广播域**。不严格地说，交换机可以看作网桥的高度集成。

  　　**冲突域**：总的来说，**冲突域就是连接在同一导线上的所有工作站的集合，或者说是同一物理网段上所有节点的集合，或以太网上竞争同一带宽的节点集合**。HUB这种设备不能分割冲突域。

  　　**广播域**：网络中能接收任一设备发出的广播帧的所有设备的集合。

  　　HUB 所有端口都在同一个广播域，冲突域内。
  　　Switch所有端口都在同一个广播域内，而每一个端口就是一个冲突域。
  　　Router的每个端口属于不同的广播域。

  ## 4 路由器

  路由器的主要工作就是为经过路由器的每个[数据帧](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%B8%A7)寻找一条最佳传输路径，并将该数据有效地传送到目的[站点](https://baike.baidu.com/item/%E7%AB%99%E7%82%B9)。由此可见，选择最佳[路径](https://baike.baidu.com/item/%E8%B7%AF%E5%BE%84)的策略即[路由算法](https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95)是路由器的关键所在。为了完成这项工作，在路由器中保存着各种传输路径的相关数据－－[路径表](https://baike.baidu.com/item/%E8%B7%AF%E5%BE%84%E8%A1%A8)（Routing Table），供[路由选择](https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9)时使用。[路径表](https://baike.baidu.com/item/%E8%B7%AF%E5%BE%84%E8%A1%A8)中保存着[子网](https://baike.baidu.com/item/%E5%AD%90%E7%BD%91)的标志信息、网上路由器的个数和下一个路由器的名字等内容。[路径表](https://baike.baidu.com/item/%E8%B7%AF%E5%BE%84%E8%A1%A8)可以是由系统[管理员](https://baike.baidu.com/item/%E7%AE%A1%E7%90%86%E5%91%98)固定设置好的。

  - [静态路由表](https://baike.baidu.com/item/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E8%A1%A8)：由[系统管理员](https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%91%98)事先设置好固定的[路径表](https://baike.baidu.com/item/%E8%B7%AF%E5%BE%84%E8%A1%A8)称之为[静态](https://baike.baidu.com/item/%E9%9D%99%E6%80%81)（static）[路径表](https://baike.baidu.com/item/%E8%B7%AF%E5%BE%84%E8%A1%A8)。
  - [动态路由表](https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E8%A1%A8)：动态（Dynamic）[路径表](https://baike.baidu.com/item/%E8%B7%AF%E5%BE%84%E8%A1%A8)是路由器根据网络系统的运行情况而自动调整的路径表。

  路由器属于OSI 模型的网络层。指导从一个网段到另一个网段的数据传输，也能指导从一种网络向另一种网络的数据传输。

  - [网络互连](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E4%BA%92%E8%BF%9E)：路由器支持各种局域网和[广域网接口](https://baike.baidu.com/item/%E5%B9%BF%E5%9F%9F%E7%BD%91%E6%8E%A5%E5%8F%A3)，主要用于互连局域网和广域网，实现不同网络互相通信；
  - [数据处理](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86)：提供包括分组过滤、分组转发、优先级、[复用](https://baike.baidu.com/item/%E5%A4%8D%E7%94%A8)、[加密](https://baike.baidu.com/item/%E5%8A%A0%E5%AF%86)、[压缩](https://baike.baidu.com/item/%E5%8E%8B%E7%BC%A9)和[防火墙](https://baike.baidu.com/item/%E9%98%B2%E7%81%AB%E5%A2%99)等功能；
  - [网络管理](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86)：路由器提供包括路由器配置管理、性能管理、容错管理和[流量](https://baike.baidu.com/item/%E6%B5%81%E9%87%8F)控制等功能。

  路由器根据路由选择协议（Routing Protocol）提供的功能，自动学习和记忆网络运行情况，在需要时自动计算数据传输的最佳[路径](https://baike.baidu.com/item/%E8%B7%AF%E5%BE%84)。

  ## 5 网络7层模型

  ![](https://github.com/wutongtongshu/img/raw/master/Network/7%E5%B1%82%E5%8D%8F%E8%AE%AE.jpg)

  ## 6 IP 是无连接的

  IP 用于计算机之间的通信。

  IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。这样，IP 就降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。

  通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。

  IP 负责将每个包路由至它的目的地。

  ## 7 IP地址

  每个计算机必须有一个 IP 地址才能够连入因特网。

  每个 IP 包必须有一个地址才能够发送到另一台计算机。

  网络上每一个节点都必须有一个独立的Internet地址（也叫做IP地址）。现在，通常使用的IP地址是一个32bit的数字，也就是我们常说的IPv4标准，这32bit的数字分成四组，也就是常见的255.255.255.255的样式。IPv4标准上，地址被分为五类，我们常用的是B类地址。具体的分类请参考其他文档。需要注意的是IP地址是网络号+主机号的组合，这非常重要。

  CP/IP 使用 32 个比特来编址。一个计算机字节是 8 比特。所以 TCP/IP 使用了 4 个字节。
  一个计算机字节可以包含 256 个不同的值：
  00000000、00000001、00000010、00000011、00000100、00000101、00000110、00000111、00001000 ....... 直到 11111111。
  现在，你知道了为什么 TCP/IP 地址是介于 0 到 255 之间的 4 个数字。

  ## 8 域名

  12 个阿拉伯数字很难记忆。使用一个名称更容易。

  用于 TCP/IP 地址的名字被称为域名。w3school.com.cn 就是一个域名。

  当你键入一个像 [http://www.w3school.com.cn](https://link.jianshu.com/?t=http://www.w3school.com.cn) 这样的域名，域名会被一种 DNS 程序翻译为数字。

  在全世界，数量庞大的 DNS 服务器被连入因特网。DNS 服务器负责将域名翻译为 TCP/IP 地址，同时负责使用新的域名信息更新彼此的系统。

  当一个新的域名连同其 TCP/IP 地址一同注册后，全世界的 DNS 服务器都会对此信息进行更新。

  ## 9 TCP和UDP的优缺点及区别

  TCP的优点： 可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。 TCP的缺点： 慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。

  UDP的优点： 快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击…… UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 基于上面的优缺点，那么： 什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 ………… 什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP ……

  有些应用场景对可靠性要求不高会用到UPD，比如长视频，要求速率

  **小结TCP与UDP的区别：**

  1.基于连接与无连接；
  2.对系统资源的要求（TCP较多，UDP少）；
  3.UDP程序结构较简单；
  4.流模式与数据报模式 ；

  5.TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。

  ```
  tcp协议和udp协议的差别 
  TCP UDP 
  是否连接 面向连接 面向非连接 
  传输可靠性 可靠 不可靠 
  应用场合 传输大量数据 少量数据 
  速度 慢 快
  ```

  TCP与UDP区别总结：

  1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接

  ```
  2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
  
  3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
  
  UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
  
  4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
  
  5、TCP首部开销20字节;UDP的首部开销小，只有8个字节
  ```

  6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

  ## 10 TCP/IP

  TCP/IP 意味着 TCP 和 IP 在一起协同工作。

  TCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。

  IP 负责计算机之间的通信。

  TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。

  IP 负责将包发送至接受者。

  ## 11 TCP报文格式

  TCP报文格式1.jpg

  16位源端口号：16位的源端口中包含初始化通信的端口。源端口和源IP地址的作用是标识报文的返回地址。

  16位目的端口号：16位的目的端口域定义传输的目的。这个端口指明报文接收计算机上的应用程序地址接口。

  32位序号：32位的序列号由接收端计算机使用，重新分段的报文成最初形式。当SYN出现，序列码实际上是初始序列码（Initial Sequence Number，ISN），而第一个数据字节是ISN+1。这个序列号（序列码）可用来补偿传输中的不一致。

  32位确认序号：32位的序列号由接收端计算机使用，重组分段的报文成最初形式。如果设置了ACK控制位，这个值表示一个准备接收的包的序列码。

  4位首部长度：4位包括TCP头大小，指示何处数据开始。

  保留（6位）：6位值域，这些位必须是0。为了将来定义新的用途而保留。

  标志：6位标志域。表示为：紧急标志、有意义的应答标志、推、重置连接标志、同步序列号标志、完成发送数据标志。按照顺序排列是：URG、ACK、PSH、RST、SYN、FIN。

  16位窗口大小：用来表示想收到的每个TCP数据段的大小。TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。窗口大小是一个16字节字段，因而窗口大小最大为65535字节。

  16位校验和：16位TCP头。源机器基于数据内容计算一个数值，收信息机要与源机器数值 结果完全一样，从而证明数据的有效性。检验和覆盖了整个的TCP报文段：这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证的。

  16位紧急指针：指向后面是优先数据的字节，在URG标志设置了时才有效。如果URG标志没有被设置，紧急域作为填充。加快处理标示为紧急的数据段。

  选项：长度不定，但长度必须为1个字节。如果没有选项就表示这个1字节的域等于0。

  数据：该TCP协议包负载的数据。

  在上述字段中，6位标志域的各个选项功能如下。

  URG：紧急标志。紧急标志为"1"表明该位有效。

  ACK：确认标志。表明确认编号栏有效。大多数情况下该标志位是置位的。TCP报头内的确认编号栏内包含的确认编号（w+1）为下一个预期的序列编号，同时提示远端系统已经成功接收所有数据。

  PSH：推标志。该标志置位时，接收端不将该数据进行队列处理，而是尽可能快地将数据转由应用处理。在处理Telnet或rlogin等交互模式的连接时，该标志总是置位的。

  RST：复位标志。用于复位相应的TCP连接。

  SYN：同步标志。表明同步序列编号栏有效。该标志仅在三次握手建立TCP连接时有效。它提示TCP连接的服务端检查序列编号，该序列编号为TCP连接初始端（一般是客户端）的初始序列编号。在这里，可以把TCP序列编号看作是一个范围从0到4，294，967，295的32位计数器。通过TCP连接交换的数据中每一个字节都经过序列编号。在TCP报头中的序列编号栏包括了TCP分段中第一个字节的序列编号。

  FIN：结束标志。

  ## 12 TCP三次握手

  所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示：

  ![握手](https://github.com/wutongtongshu/img/raw/master/Network/TCP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.gif)

  

  TCP三次握手.png

  （1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=j，并将该数据包发送给Server，Client进入SYN-SEND状态，等待Server确认。

  （2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN-RECV状态。

  （3）第三次握手：Client收到确认后，检查ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

  **SYN攻击**：

  在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：

  ```
  #netstat -nap | grep SYN_RECV
  ```

  ## 13 TCP四次挥手

  所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：

  ![img](https://github.com/wutongtongshu/img/raw/master/Network/%E5%9B%9B%E6%AC%A1%E5%88%86%E6%89%8B.png)

  由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。

  （1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。

  （2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。

  （3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。

  （4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

  ## 14 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？

  这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。

  ## 15 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

  原因有二：
  一、保证TCP协议的全双工连接能够可靠关闭
  二、保证这次连接的重复数据段从网络中消失

  先说第一点，如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。

  再说第二点，如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。

  ## 16 http 块编码

  当使用短连接的时候Recipient可以通过服务器端对Connection的关闭来正确获得消息体的结束位置；但长连接的时候Recipient怎么正确得知相邻两次请求的响应内容的分界位置呢？主要是采用设置响应头Content-Length或者Transfer-Encoding:chunked的方法来解决这一问题。 

  Chunked transfer encoding是一种数据传输机制,将消息体分成若干块从Server传输到Recipient(接收者);目前采用chunked传输方式比较多，为什么要采用chunked下面会说；如果不采用chunked传输方式则必须设置Content-Length字段，以便使Recipient能够正确获知消息体的结束位置，而为什么采用chunked不用设置Content-Length字段呢？因为chunked传输方式特定的格式可以使Recipient正确获知消息体的结束。

  Chunked传输即分块传输：将响应主体分成若干块，并在每一块前面加上该块数据的长度以及回车换行，这样Recipient（如浏览器）就可以根据这个长度值正确接收每一块数据，最后以一个0长度的分块作为消息体的结束标志。采用该传输方式Sender在开始传输响应内容到Recipient前不需要知道内容的长度。

  Chunked消息体格式如下：

  hex的分块长度+<CR>回车+<LF>换行

  chunked data

  结束块的分块长度为0

  如要发送的内容(消息体)为：123456789那么消息体的格式为：

  9<CR><LF>

  123456789<CR><LF>

  0<CR><LF>

  采用分块传输方式的好处：

  （1）由于在服务器发送数据到Recipient前不需要知道数据的字节长度，所以可以动态产生响应内容而不用先将所有数据进行缓存；由于当消息体结束的时候有明确的信号标识（0<CR><LF>），因此后面对同一HTTP服务器的请求可以复用本次连接。

  （2）允许服务器在消息体后面发送额外的响应头字段，这个非常重要当一个字段的值要等到响应内容全部产生后才能确定的情况下，如响应内容的数字签名，如果不使用分块传输服务器为了计算响应内容的算数字签名则必须先缓存所有内容直到内容产生完成。（如果不采用Chunked分块传输则在消息体后面发送的响应头不能被Recipient正确获取）

  （3）HTTP服务器有时使用compression(gzip或者deflate)方法优化传输即对被传输的字节进行压缩，chunked和gzip编码相互之间作用在HTTP编码的两个阶段；第一阶段响应内容字节流采用gzip进行压缩编码,压缩完成后产生的字节流采用chunked的方式进行传输编码，这意味着chunked和compression可以同时使用，只是作用于不同的阶段。

  其实后面几条几乎可以忽视，简单总结后如下：

  - Content-Length如果存在并且有效的话，则必须和消息内容的传输长度完全一致。（经过测试，如果过短则会截断，过长则会导致超时。）
  - 如果存在Transfer-Encoding（重点是chunked），则在header中不能有Content-Length，有也会被忽视。
  - 如果采用短连接，则直接可以通过服务器关闭连接来确定消息的传输长度。（这个很容易懂） 结合HTTP协议其他的特点，比如说Http1.1之前的不支持keep alive。那么可以得出以下结论：
  - 在Http 1.0及之前版本中，content-length字段可有可无
  - 在http1.1及之后版本。如果是keep alive，则content-length和chunk必然是二选一。若是非keep alive，则和http1.0一样。content-length可有可无。 

  HTTP/1.1 持久链接，多次请求，响应多个资源，

  content-length：指明块大小

  transfer-encoding：块传输标志

  消息体格式规定：

  ```http
  1D\r\n
  12345678912345678912345678912
  9\r\n
  123456789
  0\r\n
  ```

  上述1D表示消息长度29， \r\n 是规定加的换行符，0\r\n表示http本次事务完毕。

  ## 17 100状态码使用

  长请求体，不确定服务器是否接受，先发送确认头

   expect：100-continue

  # 2 Tomcat 4源码学习

  ## 2.1 连接器

  接受请求，封装Request和Response对象，调用Service，获取各种请求的各种信息

  ## 2.2 servlet 容器

  必须实现Container

  ## 2.3 生命周期

  NEW

  INITIALIZING
  INITIALIZED

  STARTING_PREP
  STARTING
  STARTED
  STOPPING_PREP
  STOPPING
  STOPPED

  DESTROYING
  DESTROYED

  FAILED

  ## 2.4 service

  service 封装了多个connector和一个container，由于存在多个connector，

# 3 NIO

# 4 spring mvc

# 4.1 spring功能

### 4.1.1 区域支持

每个url都支持重新获取local信息

###4.1.2 多部分文件上传 

cos和fileupload两个库，文件上传又叫多部分请求，multipartResolver负责解析，使用到上传功能时要引入bean

### 4.1.3 handlerAdaptor

### 4.1.4 hendleMapping

### 4.1.5 handlerInterceptor

### 4.1.6 handlerExceptionResovler

### 4.1.7 veiwResovler

## 4.2 各功能组建加载方式

表 1 装配各型组件的过程 

 

 

 

 

| 组件类型              | 发现机制                                                     |
| --------------------- | ------------------------------------------------------------ |
| 文件上传解析器（☆）   | 1)查找名为multipartResolver类型为MultipartResolver的Bean作为该类型组件；2)没有默认的实现类。所以如果你没有在上下文中显式定义这一类型的组件，DispatcherServlet中将不会拥有该类型的组件。 |
| 本地化解析器（☆）     | 1)查找名为localeResolver类型为LocaleResolver的Bean作为该类型·组件；2)如果找不到，使用默认的实现类(AcceptHeaderLocaleResolver)创建该类型的组件。 |
| 主题解析器（☆）       | 1)查找名为themeResolver类型为LocaleResolver的Bean作为组件；2)如果找不到，使用默认的实现类(FixedThemeResolver)。 |
| 处理器映射器（★）     | 1)如果detectAllHandlerMappings属性为true(默认为true)，根据类型匹配(HandlerMapping)机制查找上下文及父Spring容器中所有匹配的Bean，将它们作为该类型组件；2)如果detectAllHandlerMappings属性为false，查找名为handlerMapping类型为HandlerMapping的Bean作为该类型组件；3)如果通过以上方式都找不到，使用BeanNameUrlHandlerMapping实现类创建创建该类型的组件。 |
| 处理器适配器（★）     | 1)如果detectAllHandlerAdapters属性为true(默认为true)，根据类型匹配(HandlerAdapter)机制查找上下文及父Spring容器中所有匹配的Bean，将它们作为该类型组件；2)如果detectAllHandlerAdapters属性为false，查找名为handlerAdapter类型为HandlerAdapter的Bean作为该类型组件；3)如果通过以上方式都找不到，使用DispatcherServlet.properties配置文件中指定的三个实现类分别创建一个适配器，添加到适配器列表中。 |
| 处理器异常解析器（★） | 1)如果detectAllHandlerExceptionResolvers属性为true(默认为true)，根据类型匹配(HandlerExceptionResolver)机制查找上下文及父Spring容器中所有匹配的Bean作为该类型组件；2)如果detectAllHandlerExceptionResolvers属性为false，查找名为handlerExceptionResolver类型为HandlerExceptionResolver的Bean作为该类型组件；3)如果通过以上方式都找不到，查找DispatcherServlet.properties中定义的默认实现类，不过该文件中没有对应处理器异常解析器的默认实现类（你可以更改属性文件）。 |
| 视图名翻译器（☆）     | 1)查找名为viewNameTranslator类型为RequestToViewNameTranslator的Bean作为该类型组件；2)如果1)找不到，使用默认的实现类(DefaultRequestToViewNameTranslator)创建该类型的组件。 |
| 视图解析器（★）       | 1)如果detectAllViewResolvers属性为true(默认为true)，根据类型匹配(ViewResolver)机制查找上下文及父Spring容器中所有匹配的Bean作为该类型组件；2)如果detectAllViewResolvers属性为false，查找名为viewResolver类型为ViewResolver的Bean作为该类型组件；3)如果通过以上方式都找不到，通过DispatcherServlet.properties中定义的默认实现类（InternalResourceViewResolver）创建该类型的组件。 |
|                       |                                                              |

# 



