# 网络基础

## 1 集线器

　　集线器（HUB），它是工作在物理层的设备， 由于它只是工作在物理层，它的工作机制流程是：从一个端口接收到数据包时，会在其他端口把这个包转发一次，因为它不知道也不可能知道这个包是发给谁的（物理层设备只关心电压这些物理概念），它也只能对所有人广播(这里和下文提到的 广播该词的意思和ARP请求时的广播有些不同，这里的广播意思是：使用物理层转发设备，如HUB，导致的广播，可以说这个广播是被逼的，因为设备的问题！ 是设备转发包引起的广播！而ARP请求的广播是自己要求的，主动的，因为ARP请求包的目标地址IP是255.255.255.255，但ARP请求的广 播涉及IP层的知识，不在这篇文章讨论的范围，所以这里提到的广播，除非特别说明，否则都是第一个意思，也就说是"因设备转发数据包引起的广播" )。

　　这样一来会有不少问题，你发的数据其他人都收到了，私隐这总东西是不存在的！别入可以随便监听你信息！所以会话劫持在那个年代相当容易。

　　另外一个比较严重的问题是，如果一个大型的局域网，比如有500台机器，全部用HUB连接的无用的数据包会充斥着整个的局域网，这就是传说中的广播风暴！

　　为了减少广播风暴，**网桥**产生了（注意这里用的时候“减少”，不是“杜绝”，仅仅是减少!如果仅仅用网桥说能杜绝广播风暴，个人觉得还是不太准确，后来交换机的出现才可以说是完全杜绝了广播风暴的发生）！

　　在介绍网桥之前，还想简单介绍另一个物理层的设备：“中继器”，这种设备的作用是把物理层传输的信号放大，由于长距离的传输，信号会有一定的损耗的，这种设备主要解决的就是这个问题。它和HUB的区别是：HUB主要是为了在物理层上转发数据的，所以它不关心电压值的大小，也不会放大物理信号；而中继器它的作用就是为了放大信号用的

## 2 网桥

　　网桥又称桥接器，英文名Network Bridge，**数据链路层设备**。它也是转发数据包的设备，但和HUB不一样的是，它工作在数据链路层，HUB只能看懂物理层上的东西（比如一段物理信号），网桥却能看懂一些帧的信息（在链路层上，把上面传下来的数据封装后，封装好了的数据就是帧，但这里我用“数据包”这样的泛指去代替“帧”这个专业术语）。在以太网构造的局域网上，最终的寻址是以数据链路层的MAC地址作为标识的(就是用MAC地址可以在局域网上找到一台唯一的机器)，网桥能从发来的数据包中提取MAC信息，并且根据MAC信息对数据包进行有目的的转发，而不采用广播的方式，这样就能减少广播风暴的出现，提升整个网络的效率，在详细说网桥这东西之前，我想先介绍一下交换机。

## 3 交换机

　　交换机Switch，数据链路层设备，作用是转发数据包。和网桥一样它也是通过识别帧中的MAC地址，然后对特定的端口进行转发的。

### 3.1 网桥和交换机的工作原理及区别

　　回答网桥和交换机区别之前，我们先一起看两幅图(这是从《计算机网络(第四版)》第四章截下来的:>)：

　　1.网桥的连接模式：(红点处为HUB)

　　![img](https://github.com/wutongtongshu/img/raw/master/Network/%E9%9B%86%E7%BA%BF%E5%99%A8.jpg)

　　2.交换机连接模式：

　　![img](https://github.com/wutongtongshu/img/raw/master/Network/%E4%BA%A4%E6%8D%A2%E6%9C%BA.jpg)

　　从图中可以看到，网桥只有2个输入/出端口，而交换机有8个。嗯，是的，一开始的时候(那时候只有HUB这种设备)，由于硬件水平不是很发达，人们为了提高局域网效率，减少广播风暴的出现，他们生产了网桥（一个只有两个输入/出端口的链路层设备，这时的网桥已经是个比较先进的设备），然后他们把一个局域网一分为2，中间用网桥连接，这样A发给BCD的数据就不会再广播到EFGH了(网桥发现如果数据包不是转发给下面这个子网的，它会自动丢弃此包)，只有从A发到EFGH的数据包才能通过网桥，到达另外一个子网(网桥发现如果数据包是转发给下面这个子网的，它才会把包转发给这个子网)。这样一来，非必要的传输减少了，整个网络的效率也随之提高可不少！人们发现网桥真是个好东西呀，随着硬件发展，出现了4个，8个端口的链路层设备，这就是交换机，由于交换机可以使得网络更安全(数据不容易被监听，因为数据不再广播了，注意：只是不容易而已，要搞你其实还是可以的)，网络效率更高(还是因为数据不再广播！)，交换机渐渐替代了HUB，成为组建局域网的重要设备。

　　所以说，网桥和交换机，基本上是一样的，嗯，只是基本上而已，细看还是有些不一样的，但在说明他们之间有什么不一样之前，我想先简单介绍一下网桥和交换机的工作原理。

　　3.网桥的工作原理：　　

![img](https://github.com/wutongtongshu/img/raw/master/Network/%E7%BD%91%E6%A1%A5%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg)

　　上图是用一个网桥连接的两个网络，网桥的A端口连接A子网，B端口连接B子网，为什么网桥知道哪些数据包该转发，哪些包不该转发呢？那是因为它有两个表A和B，当有数据包进入端口A时，网桥从数据包中提取出源MAC地址和目的MAC地址，一开始的时候，表A和表B都是空的，没有一条记录，这时，网桥会把数据包转发给B网络，并且在表A中增加一条MAC地址(把**源MAC地址记录表中**)，说明这个MAC地址的机器是A子网的，同理，当B子网发送数据包到B端口时，网桥也会记录**源MAC地址**到B表；当网桥工作一段时候后，表A基本上记录了A子网所有的机器的MAC地址，表B同理，当再有一个数据包从A子网发送给网桥时，网桥会先看看数据包的目的MAC地址是属于A子网还是B子网的，如果从A表中找到对应则，抛弃该包，如果不是，则转发给B子网，然后检查源MAC地址，是否在表中已经存在，如果不存在，在表A中增加一条记录。

　　噢，或许你现在会问了，为什么需要两张表呢，一张表不行么？？嗯～刚才把表一分为二是为了便于理解，实际上，真正的网桥里面存的应该是一张表(当然有可能为了提速，或者其他原因，它也可能把信息存为多张表，这个得看它怎么实现了～)，如果是一张信息表，表里记录的应该是：MAC-PortNum。

　　4.交换机有些许不同，如图：

![img](https://github.com/wutongtongshu/img/raw/master/Network/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg)

　　交换机也有一张MAC-PORT对应表(这张表的学名为：**CAM**)，和网桥不一样的是，网桥的表是一对多的(一个端口号对多个MAC地址)，但交换机的CAM表却是一对一的，如果一个端口有新的MAC地址，它不会新增MAC－PORT记录，而是修改原有的记录，比如：现在交换机记录表里已经有一项：MAC1-Port1，如果此刻端口1又来了一个数据包，里面的源MAC地址是MAC2，此时，交换机会刷新交换机记录表：MAC1-Port1记录被修改为MAC2－Port1，因为交换机认为是端口1的计算机MAC地址变了，如果端口1连接的一台物理机器，MAC一般是不会变的，如果连接的是另外一个交换机，那这个端口的记录会变化得比较频繁(如上图的Port12，它是对外的接口，与一个局域网连接)，另外，如果CAM表中没有找到和数据包的目的MAC地址对应的记录，交换机会对此数据包进行广播，发给本交换机的每一个端口。

　　网桥和交换机除了用CAM表指导数据包转发这点和HUB不一样外，网桥和交换机还有一个特点：缓存！对，网桥和交换机都有一定量的缓存，因为网桥和交换机转发数据包需要一些额外的操作，所以可能会占用一些时间，为了避免出现因来不及转发数据，导致大量数据丢失的情况，网桥和交换机就出现了缓存。当然，缓存不是万能的，当网桥或交换机处理不及并且缓存用完了，以后再来的数据还是会丢失的。还一个网桥需要缓存的原因是：桥接两个传输速率不同的局域网，比如：802.3的传输速率说10mb/s，但实际上并不是真的10Mb/s，而 802.4(几乎)确实为10Mb/s，但两个局域网桥接时候必须是速率一样的，否则会有包丢失，而缓存也正好可以为不同速率网络连接时所使用。这里需要对比一下网桥和交换机的缓存，一般来说，网桥的缓存量是大于交换机的缓存量，因为网桥天生是为了连接两个网络的，两个网络桥接时所要处理的数据量会比一般的交换机需要处理的数据量要多，所以网桥的缓存也一般要比交换机大一点。

　　值得注意的一些问题：

　　1). 网桥需要软件辅助？

　　回答这个问题，首先要看看原始的网桥，《计算机网络(第四版)》里有一段话是这样的：传统上，网桥往往包含一个CPU，"转发-存储"由软件来实现。噢，**以前的网桥是这样的**，但现在由于硬件水平的提升，网桥，交换机都包含了特殊的，用于转发的集成电路部分，现在的网桥和交换机都可以不需要软件辅助了！顺带说一句，模拟网桥功能的软件现在也是有的。

　　2). 网桥用于连接不同的网段？(搜索百度时查到一个答案)

　　首先这里要理解什么是**网段**，唉，这个概念说起来又是一篇文章！它涉及到子网掩码的等等一系列的东西....

　　这里我觉得要明确的是，**网桥不是用来连接不同网段的**！！！我当初被这个问题害惨了，K了N多资料，不过还好，有点收获:>，不同网段之间通信，需要网关的帮助，它一般是路由器这类网络层的设备。网桥或交换机是链路层设备，网段这个是和IP相关的概念，属于网络层。网桥和交换机跟本无能力去处理网络层的东西！如果非要说用网桥和交换机去连接两个不同网段的网络不是不行，只是没有作用而已，因为不同网段机器的始终是不能互访问，网桥不能做网关！上面我已经说了网桥的由来，它是为了减少HUB的广播，提高局域网网络性能出现的，网桥连接的仅仅是两个子局域网，并且这里说的子局域网必须是同构的(同构的意思是：如果是以太网，那么网桥连接的两个子网都必须是以太网，不能一个是以太网一个是令牌网)，我一直认为：以太网的特性导致了网桥的出现，因为广播是以太网的重要特性，其他构造的网络不一定有（呀～这里我猜的，我对其他的结构的网络是一巧不通的说-_-!），为了优化以太网的性能，网桥出现了～所以**其他构造网络似乎也不需要使用网桥**这个东东！其实后来带着这个想法继续看无线网络的东西，发现这个想法应该是错误的，**网桥的天性应该是：连接两个同构网络**，而在以太网上，刚好HUB可以作为连接两个网络的设备，但是由于HUB的各种弊端，人们研发了工作在链路层上的网桥（本文所介绍的），它除了连接两个网络的功能外，还有优化网络性能的功能。而在其他构造的网络也有网桥这个设备，但它的功能可能是仅仅连接两个网络，而没有了优化网络性能的功能（或者根据网络特性，它又有了新的功能）。

　　**这里再次总结一下网桥和交换机**：

　　网桥和交换机用户**分割冲突域**，就是网桥和交换机可以较少**被逼的广播(hub导致的)**，但**不能分割广播域**。不严格地说，交换机可以看作网桥的高度集成。

　　**冲突域**：总的来说，**冲突域就是连接在同一导线上的所有工作站的集合，或者说是同一物理网段上所有节点的集合，或以太网上竞争同一带宽的节点集合**。HUB这种设备不能分割冲突域。

　　**广播域**：网络中能接收任一设备发出的广播帧的所有设备的集合。

　　HUB 所有端口都在同一个广播域，冲突域内。
　　Switch所有端口都在同一个广播域内，而每一个端口就是一个冲突域。
　　Router的每个端口属于不同的广播域。

## 4 路由器

路由器的主要工作就是为经过路由器的每个[数据帧](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%B8%A7)寻找一条最佳传输路径，并将该数据有效地传送到目的[站点](https://baike.baidu.com/item/%E7%AB%99%E7%82%B9)。由此可见，选择最佳[路径](https://baike.baidu.com/item/%E8%B7%AF%E5%BE%84)的策略即[路由算法](https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95)是路由器的关键所在。为了完成这项工作，在路由器中保存着各种传输路径的相关数据－－[路径表](https://baike.baidu.com/item/%E8%B7%AF%E5%BE%84%E8%A1%A8)（Routing Table），供[路由选择](https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9)时使用。[路径表](https://baike.baidu.com/item/%E8%B7%AF%E5%BE%84%E8%A1%A8)中保存着[子网](https://baike.baidu.com/item/%E5%AD%90%E7%BD%91)的标志信息、网上路由器的个数和下一个路由器的名字等内容。[路径表](https://baike.baidu.com/item/%E8%B7%AF%E5%BE%84%E8%A1%A8)可以是由系统[管理员](https://baike.baidu.com/item/%E7%AE%A1%E7%90%86%E5%91%98)固定设置好的。

- [静态路由表](https://baike.baidu.com/item/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E8%A1%A8)：由[系统管理员](https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%91%98)事先设置好固定的[路径表](https://baike.baidu.com/item/%E8%B7%AF%E5%BE%84%E8%A1%A8)称之为[静态](https://baike.baidu.com/item/%E9%9D%99%E6%80%81)（static）[路径表](https://baike.baidu.com/item/%E8%B7%AF%E5%BE%84%E8%A1%A8)。
- [动态路由表](https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E8%A1%A8)：动态（Dynamic）[路径表](https://baike.baidu.com/item/%E8%B7%AF%E5%BE%84%E8%A1%A8)是路由器根据网络系统的运行情况而自动调整的路径表。

路由器属于OSI 模型的网络层。指导从一个网段到另一个网段的数据传输，也能指导从一种网络向另一种网络的数据传输。

- [网络互连](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E4%BA%92%E8%BF%9E)：路由器支持各种局域网和[广域网接口](https://baike.baidu.com/item/%E5%B9%BF%E5%9F%9F%E7%BD%91%E6%8E%A5%E5%8F%A3)，主要用于互连局域网和广域网，实现不同网络互相通信；
- [数据处理](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86)：提供包括分组过滤、分组转发、优先级、[复用](https://baike.baidu.com/item/%E5%A4%8D%E7%94%A8)、[加密](https://baike.baidu.com/item/%E5%8A%A0%E5%AF%86)、[压缩](https://baike.baidu.com/item/%E5%8E%8B%E7%BC%A9)和[防火墙](https://baike.baidu.com/item/%E9%98%B2%E7%81%AB%E5%A2%99)等功能；
- [网络管理](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86)：路由器提供包括路由器配置管理、性能管理、容错管理和[流量](https://baike.baidu.com/item/%E6%B5%81%E9%87%8F)控制等功能。

路由器根据路由选择协议（Routing Protocol）提供的功能，自动学习和记忆网络运行情况，在需要时自动计算数据传输的最佳[路径](https://baike.baidu.com/item/%E8%B7%AF%E5%BE%84)。

## 5 网络7层模型

![](https://github.com/wutongtongshu/img/raw/master/Network/7%E5%B1%82%E5%8D%8F%E8%AE%AE.jpg)

## 6 IP 是无连接的

IP 用于计算机之间的通信。

IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。这样，IP 就降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。

通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。

IP 负责将每个包路由至它的目的地。

## 7 IP地址

每个计算机必须有一个 IP 地址才能够连入因特网。

每个 IP 包必须有一个地址才能够发送到另一台计算机。

网络上每一个节点都必须有一个独立的Internet地址（也叫做IP地址）。现在，通常使用的IP地址是一个32bit的数字，也就是我们常说的IPv4标准，这32bit的数字分成四组，也就是常见的255.255.255.255的样式。IPv4标准上，地址被分为五类，我们常用的是B类地址。具体的分类请参考其他文档。需要注意的是IP地址是网络号+主机号的组合，这非常重要。

CP/IP 使用 32 个比特来编址。一个计算机字节是 8 比特。所以 TCP/IP 使用了 4 个字节。
一个计算机字节可以包含 256 个不同的值：
00000000、00000001、00000010、00000011、00000100、00000101、00000110、00000111、00001000 ....... 直到 11111111。
现在，你知道了为什么 TCP/IP 地址是介于 0 到 255 之间的 4 个数字。

## 8 域名

12 个阿拉伯数字很难记忆。使用一个名称更容易。

用于 TCP/IP 地址的名字被称为域名。w3school.com.cn 就是一个域名。

当你键入一个像 [http://www.w3school.com.cn](https://link.jianshu.com/?t=http://www.w3school.com.cn) 这样的域名，域名会被一种 DNS 程序翻译为数字。

在全世界，数量庞大的 DNS 服务器被连入因特网。DNS 服务器负责将域名翻译为 TCP/IP 地址，同时负责使用新的域名信息更新彼此的系统。

当一个新的域名连同其 TCP/IP 地址一同注册后，全世界的 DNS 服务器都会对此信息进行更新。

## 9 TCP和UDP的优缺点及区别

TCP的优点： 可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。 TCP的缺点： 慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。

UDP的优点： 快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击…… UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 基于上面的优缺点，那么： 什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 ………… 什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP ……

有些应用场景对可靠性要求不高会用到UPD，比如长视频，要求速率

**小结TCP与UDP的区别：**

1.基于连接与无连接；
2.对系统资源的要求（TCP较多，UDP少）；
3.UDP程序结构较简单；
4.流模式与数据报模式 ；

5.TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。

```
tcp协议和udp协议的差别 
TCP UDP 
是否连接 面向连接 面向非连接 
传输可靠性 可靠 不可靠 
应用场合 传输大量数据 少量数据 
速度 慢 快
```

TCP与UDP区别总结：

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接

```
2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的

UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）

4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

5、TCP首部开销20字节;UDP的首部开销小，只有8个字节
```

6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

## 10 TCP/IP

TCP/IP 意味着 TCP 和 IP 在一起协同工作。

TCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。

IP 负责计算机之间的通信。

TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。

IP 负责将包发送至接受者。

## 11 TCP报文格式

TCP报文格式1.jpg

16位源端口号：16位的源端口中包含初始化通信的端口。源端口和源IP地址的作用是标识报文的返回地址。

16位目的端口号：16位的目的端口域定义传输的目的。这个端口指明报文接收计算机上的应用程序地址接口。

32位序号：32位的序列号由接收端计算机使用，重新分段的报文成最初形式。当SYN出现，序列码实际上是初始序列码（Initial Sequence Number，ISN），而第一个数据字节是ISN+1。这个序列号（序列码）可用来补偿传输中的不一致。

32位确认序号：32位的序列号由接收端计算机使用，重组分段的报文成最初形式。如果设置了ACK控制位，这个值表示一个准备接收的包的序列码。

4位首部长度：4位包括TCP头大小，指示何处数据开始。

保留（6位）：6位值域，这些位必须是0。为了将来定义新的用途而保留。

标志：6位标志域。表示为：紧急标志、有意义的应答标志、推、重置连接标志、同步序列号标志、完成发送数据标志。按照顺序排列是：URG、ACK、PSH、RST、SYN、FIN。

16位窗口大小：用来表示想收到的每个TCP数据段的大小。TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。窗口大小是一个16字节字段，因而窗口大小最大为65535字节。

16位校验和：16位TCP头。源机器基于数据内容计算一个数值，收信息机要与源机器数值 结果完全一样，从而证明数据的有效性。检验和覆盖了整个的TCP报文段：这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证的。

16位紧急指针：指向后面是优先数据的字节，在URG标志设置了时才有效。如果URG标志没有被设置，紧急域作为填充。加快处理标示为紧急的数据段。

选项：长度不定，但长度必须为1个字节。如果没有选项就表示这个1字节的域等于0。

数据：该TCP协议包负载的数据。

在上述字段中，6位标志域的各个选项功能如下。

URG：紧急标志。紧急标志为"1"表明该位有效。

ACK：确认标志。表明确认编号栏有效。大多数情况下该标志位是置位的。TCP报头内的确认编号栏内包含的确认编号（w+1）为下一个预期的序列编号，同时提示远端系统已经成功接收所有数据。

PSH：推标志。该标志置位时，接收端不将该数据进行队列处理，而是尽可能快地将数据转由应用处理。在处理Telnet或rlogin等交互模式的连接时，该标志总是置位的。

RST：复位标志。用于复位相应的TCP连接。

SYN：同步标志。表明同步序列编号栏有效。该标志仅在三次握手建立TCP连接时有效。它提示TCP连接的服务端检查序列编号，该序列编号为TCP连接初始端（一般是客户端）的初始序列编号。在这里，可以把TCP序列编号看作是一个范围从0到4，294，967，295的32位计数器。通过TCP连接交换的数据中每一个字节都经过序列编号。在TCP报头中的序列编号栏包括了TCP分段中第一个字节的序列编号。

FIN：结束标志。

## 12 TCP三次握手

所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示：

![握手](https://github.com/wutongtongshu/img/raw/master/Network/TCP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.gif)



TCP三次握手.png

（1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=j，并将该数据包发送给Server，Client进入SYN-SEND状态，等待Server确认。

（2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN-RECV状态。

（3）第三次握手：Client收到确认后，检查ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

**SYN攻击**：

在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：

```
#netstat -nap | grep SYN_RECV
```

## 13 TCP四次挥手

所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：

![img](https://github.com/wutongtongshu/img/raw/master/Network/%E5%9B%9B%E6%AC%A1%E5%88%86%E6%89%8B.png)

由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。

（1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。

（2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。

（3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。

（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

## 14 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？

这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。

## 15 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

原因有二：
一、保证TCP协议的全双工连接能够可靠关闭
二、保证这次连接的重复数据段从网络中消失

先说第一点，如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。

再说第二点，如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。

## 16 http 块编码

当使用短连接的时候Recipient可以通过服务器端对Connection的关闭来正确获得消息体的结束位置；但长连接的时候Recipient怎么正确得知相邻两次请求的响应内容的分界位置呢？主要是采用设置响应头Content-Length或者Transfer-Encoding:chunked的方法来解决这一问题。 

Chunked transfer encoding是一种数据传输机制,将消息体分成若干块从Server传输到Recipient(接收者);目前采用chunked传输方式比较多，为什么要采用chunked下面会说；如果不采用chunked传输方式则必须设置Content-Length字段，以便使Recipient能够正确获知消息体的结束位置，而为什么采用chunked不用设置Content-Length字段呢？因为chunked传输方式特定的格式可以使Recipient正确获知消息体的结束。

Chunked传输即分块传输：将响应主体分成若干块，并在每一块前面加上该块数据的长度以及回车换行，这样Recipient（如浏览器）就可以根据这个长度值正确接收每一块数据，最后以一个0长度的分块作为消息体的结束标志。采用该传输方式Sender在开始传输响应内容到Recipient前不需要知道内容的长度。

Chunked消息体格式如下：

hex的分块长度+<CR>回车+<LF>换行

chunked data

结束块的分块长度为0

如要发送的内容(消息体)为：123456789那么消息体的格式为：

9<CR><LF>

123456789<CR><LF>

0<CR><LF>

采用分块传输方式的好处：

（1）由于在服务器发送数据到Recipient前不需要知道数据的字节长度，所以可以动态产生响应内容而不用先将所有数据进行缓存；由于当消息体结束的时候有明确的信号标识（0<CR><LF>），因此后面对同一HTTP服务器的请求可以复用本次连接。

（2）允许服务器在消息体后面发送额外的响应头字段，这个非常重要当一个字段的值要等到响应内容全部产生后才能确定的情况下，如响应内容的数字签名，如果不使用分块传输服务器为了计算响应内容的算数字签名则必须先缓存所有内容直到内容产生完成。（如果不采用Chunked分块传输则在消息体后面发送的响应头不能被Recipient正确获取）

（3）HTTP服务器有时使用compression(gzip或者deflate)方法优化传输即对被传输的字节进行压缩，chunked和gzip编码相互之间作用在HTTP编码的两个阶段；第一阶段响应内容字节流采用gzip进行压缩编码,压缩完成后产生的字节流采用chunked的方式进行传输编码，这意味着chunked和compression可以同时使用，只是作用于不同的阶段。

其实后面几条几乎可以忽视，简单总结后如下：

-  Content-Length如果存在并且有效的话，则必须和消息内容的传输长度完全一致。（经过测试，如果过短则会截断，过长则会导致超时。）
- 如果存在Transfer-Encoding（重点是chunked），则在header中不能有Content-Length，有也会被忽视。
- 如果采用短连接，则直接可以通过服务器关闭连接来确定消息的传输长度。（这个很容易懂） 结合HTTP协议其他的特点，比如说Http1.1之前的不支持keep alive。那么可以得出以下结论：
-  在Http 1.0及之前版本中，content-length字段可有可无
- 在http1.1及之后版本。如果是keep alive，则content-length和chunk必然是二选一。若是非keep alive，则和http1.0一样。content-length可有可无。 

HTTP/1.1 持久链接，多次请求，响应多个资源，

content-length：指明块大小

transfer-encoding：块传输标志

消息体格式规定：

```http
1D\r\n
12345678912345678912345678912
9\r\n
123456789
0\r\n
```

上述1D表示消息长度29， \r\n 是规定加的换行符，0\r\n表示http本次事务完毕。

## 17 100状态码使用

长请求体，不确定服务器是否接受，先发送确认头

 expect：100-continue

# 2 Tomcat 4源码学习

## 2.1 连接器

接受请求，封装Request和Response对象，调用Service，获取各种请求的各种信息

## 2.2 servlet 容器

必须实现Container

## 2.3 生命周期

NEW

INITIALIZING
INITIALIZED

STARTING_PREP
STARTING
STARTED
STOPPING_PREP
STOPPING
STOPPED

DESTROYING
DESTROYED

FAILED

## 2.4 service

service 封装了多个connector和一个container，由于存在多个connector，